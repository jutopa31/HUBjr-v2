‚úÖ Instrucciones ejecutivas al inicio (orden de trabajo,
  reglas cr√≠ticas, tiempos estimados)
  ‚úÖ Arquitectura detallada (2 archivos nuevos + 2
  modificados)
  ‚úÖ Flujos de usuario paso a paso para ambos m√≥dulos
  ‚úÖ C√≥digo de ejemplo para cada funci√≥n/componente
  ‚úÖ Checklist de implementaci√≥n con 40+ items
  ‚úÖ Testing y validaci√≥n con casos de prueba espec√≠ficos

  Puntos clave del plan:
  - Crear servicio ocrAutoService.ts para l√≥gica de
  procesamiento
  - Crear modal OCRStudiesModal.tsx con preview editable
  - Integrar bot√≥n OCR en secci√≥n "Estudios Complementarios"
   de Ward Rounds
  - Reutilizar modal existente en Evolucionador
  - NO guardar im√°genes (solo texto extra√≠do)
  - Procesamiento secuencial para mejor UX

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 Ready to code?

 Here is Claude's plan:
‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå‚ïå
 Plan: Integraci√≥n de OCR Autom√°tico para Estudios
 Complementarios

 üöÄ Instrucciones para el Agente Ejecutor

 Antes de empezar:
 1. Lee completo las secciones 1-9 del plan (arquitectura y
 decisiones clave)
 2. Usa npx tsc --noEmit antes de cada commit para validar
 TypeScript
 3. Prueba cada componente aisladamente antes de integrar

 Orden recomendado de trabajo:
 1. Primero: Crea ocrAutoService.ts (servicios/l√≥gica) - 30 min
 2. Segundo: Crea OCRStudiesModal.tsx (UI/modal) - 1 hora
 3. Tercero: Integra en Ward Rounds (m√°s complejo) - 2 horas
 4. Cuarto: Integra en Evolucionador (simple, reutiliza
 componente) - 30 min
 5. √öltimo: Testing exhaustivo en mobile + desktop - 1 hora

 Reglas cr√≠ticas:
 - ‚ö†Ô∏è NO guardar im√°genes en Supabase Storage - solo extraer y
 descartar
 - ‚ö†Ô∏è El bot√≥n OCR en Ward Rounds debe estar en secci√≥n
 "Estudios Complementarios", NO en galer√≠a de im√°genes
 - ‚ö†Ô∏è Usar concatenaci√≥n simple (texto1\n\ntexto2) para
 m√∫ltiples archivos
 - ‚ö†Ô∏è Modal debe permitir editar el texto antes de confirmar
 - ‚ö†Ô∏è Procesamiento secuencial (uno por uno) para evitar colgar
  el navegador

 Si algo no est√° claro:
 - Busca patrones similares en OCRProcessorModal.tsx y
 ocrService.ts
 - Sigue las convenciones de CLAUDE.md (dark mode, manejo de
 errores, TypeScript estricto)

 ---
 Resumen Ejecutivo

 Integrar procesamiento OCR autom√°tico de im√°genes JPEG para
 extraer texto de estudios complementarios (laboratorios, ECG,
 etc.) en dos m√≥dulos principales:
 - Ward Rounds (Pase de Sala): Bot√≥n dedicado en secci√≥n
 "Estudios Complementarios"
 - Evolucionador: Reemplazar bot√≥n OCR existente con
 funcionalidad autom√°tica

 Flujo: Usuario carga JPEG ‚Üí OCR autom√°tico ‚Üí Preview con texto
  extra√≠do ‚Üí Usuario confirma/edita ‚Üí Texto se agrega al campo
 ‚Üí Imagen se descarta (no se guarda en storage).

 ---
 Decisiones de Dise√±o Confirmadas

 UX y Comportamiento

 - ‚úÖ Flujo: Autom√°tico con preview (modal de confirmaci√≥n)
 - ‚úÖ M√∫ltiples im√°genes: Concatenaci√≥n simple (texto tras
 texto separado por saltos de l√≠nea)
 - ‚úÖ Almacenamiento: Solo guardar texto extra√≠do, NO la imagen
 - ‚úÖ Formato: Texto libre sin estructura adicional
 - ‚úÖ Ubicaci√≥n Ward Rounds: Bot√≥n separado en secci√≥n
 "Estudios Complementarios" (NO en galer√≠a de im√°genes)
 - ‚úÖ Ubicaci√≥n Evolucionador: Reemplazar bot√≥n "OCR notas"
 existente

 Manejo de Errores

 - Si OCR falla: Mostrar error, permitir ingreso manual, NO
 guardar imagen
 - Si no detecta texto: Advertir al usuario y permitir
 reintento o cancelaci√≥n

 ---
 Arquitectura de la Soluci√≥n

 1. Nuevo Servicio: ocrAutoService.ts

 Ubicaci√≥n: src/services/ocrAutoService.ts

 Responsabilidades:
 - Wrapper sobre ocrService.ts existente
 - Manejar procesamiento de m√∫ltiples archivos
 - Formatear texto concatenado
 - Validaci√≥n de formatos soportados

 Funciones principales:
 // Procesar un solo archivo JPEG
 async function processImageForStudies(
   file: File,
   onProgress?: (progress: number) => void
 ): Promise<{ success: boolean; text: string; error?: string }>

 // Procesar m√∫ltiples archivos
 async function processMultipleImagesForStudies(
   files: File[],
   onProgress?: (current: number, total: number, text: string)
 => void
 ): Promise<{ success: boolean; concatenatedText: string;
 errors: string[] }>

 // Validar formato de archivo
 function isValidStudyImage(file: File): boolean

 L√≥gica de concatenaci√≥n:
 // Ejemplo: 3 archivos procesados
 // Resultado: "texto1\n\ntexto2\n\ntexto3"
 const concatenatedText = results
   .filter(r => r.success)
   .map(r => r.text.trim())
   .join('\n\n');

 ---
 2. Nuevo Componente: OCRStudiesModal.tsx

 Ubicaci√≥n: src/components/OCRStudiesModal.tsx

 Funcionalidad:
 - Modal de preview con texto extra√≠do
 - Permite edici√≥n antes de confirmar
 - Muestra progreso durante procesamiento OCR
 - Botones: "Agregar al campo", "Cancelar"

 Props:
 interface OCRStudiesModalProps {
   isOpen: boolean;
   onClose: () => void;
   onConfirm: (extractedText: string) => void;
   files: File[];
 }

 Estados internos:
 const [isProcessing, setIsProcessing] = useState(false);
 const [progress, setProgress] = useState({ current: 0, total:
 0 });
 const [extractedText, setExtractedText] = useState('');
 const [errors, setErrors] = useState<string[]>([]);

 Flujo visual:
 1. Estado "Procesando": Spinner + "Procesando archivo 1 de
 3..." + barra de progreso
 2. Estado "Completado": Textarea con texto extra√≠do (editable)
  + botones de acci√≥n
 3. Estado "Error": Mensaje de error + opci√≥n de reintentar o
 cancelar

 ---
 3. Modificaciones en WardRounds.tsx

 Archivos a modificar: src/WardRounds.tsx

 3.1. Nuevos Estados

 // Agregar despu√©s de l√≠nea ~135 (donde est√°n otros estados de
  imagen)
 const [showOcrStudiesModal, setShowOcrStudiesModal] =
 useState(false);
 const [ocrFiles, setOcrFiles] = useState<File[]>([]);
 const [ocrProcessing, setOcrProcessing] = useState(false);

 3.2. Nueva Funci√≥n: handleOcrStudiesUpload

 // Agregar cerca de l√≠nea ~855 (junto a
 handleMultipleFileUpload)
 const handleOcrStudiesUpload = useCallback(async (files:
 FileList | null) => {
   if (!files || files.length === 0) return;

   // Validar que todos sean im√°genes v√°lidas
   const validFiles =
 Array.from(files).filter(isValidStudyImage);

   if (validFiles.length === 0) {
     toast.error('Solo se aceptan im√°genes JPEG, PNG, BMP o
 TIFF');
     return;
   }

   // Guardar archivos y abrir modal
   setOcrFiles(validFiles);
   setShowOcrStudiesModal(true);
 }, []);

 3.3. Funci√≥n: handleOcrTextConfirmed

 const handleOcrTextConfirmed = useCallback((extractedText:
 string) => {
   if (editingPatient) {
     // Modo edici√≥n: agregar al campo estudios existente
     const currentStudies = editingPatient.estudios || '';
     const updatedStudies = currentStudies.trim()
       ? `${currentStudies.trim()}\n\n${extractedText.trim()}`
       : extractedText.trim();

     setEditingPatient({ ...editingPatient, estudios:
 updatedStudies });
   } else {
     // Modo agregar nuevo: agregar al newPatient
     const currentStudies = newPatient.estudios || '';
     const updatedStudies = currentStudies.trim()
       ? `${currentStudies.trim()}\n\n${extractedText.trim()}`
       : extractedText.trim();

     setNewPatient({ ...newPatient, estudios: updatedStudies
 });
   }

   setShowOcrStudiesModal(false);
   setOcrFiles([]);

   toast.success('Texto agregado a estudios complementarios');
 }, [editingPatient, newPatient]);

 3.4. Modificar UI - Secci√≥n de Estudios Complementarios

 Ubicaci√≥n: L√≠nea ~2428-2444 (formulario de agregar) y l√≠nea
 ~3431-3447 (formulario de edici√≥n)

 Cambios:

 {/* Campo Estudios Complementarios - AGREGAR */}
 <div className="col-span-2">
   <label className="flex items-center gap-2 text-sm
 font-medium text-gray-700 dark:text-gray-300 mb-1">
     <FlaskConical size={16} />
     Estudios Complementarios
   </label>

   {/* NUEVO: Bot√≥n OCR para estudios */}
   <div className="flex gap-2 mb-2">
     <input
       type="file"
       ref={ocrStudiesInputRef}
       onChange={(e) => handleOcrStudiesUpload(e.target.files)}

 accept="image/jpeg,image/jpg,image/png,image/bmp,image/tiff"
       multiple
       className="hidden"
     />
     <button
       type="button"
       onClick={() => ocrStudiesInputRef.current?.click()}
       disabled={ocrProcessing}
       className="flex items-center gap-2 px-3 py-1.5 text-sm
 bg-purple-600 text-white rounded hover:bg-purple-700
 disabled:opacity-50"
     >
       <FileText size={16} />
       {ocrProcessing ? 'Procesando...' : 'Extraer texto
 (OCR)'}
     </button>
     <span className="text-xs text-gray-500 dark:text-gray-400
 self-center">
       Carga im√°genes JPEG de estudios para extraer texto
 autom√°ticamente
     </span>
   </div>

   {/* Campo textarea existente */}
   <textarea
     placeholder="TC sin contraste, laboratorio, ECG..."
     value={newPatient.estudios}
     onChange={(e) => setNewPatient({ ...newPatient, estudios:
 e.target.value })}
     className="w-full px-3 py-2 border border-gray-300
 dark:border-gray-600 rounded-md..."
     rows={3}
   />
 </div>

 Mismo patr√≥n para el formulario de edici√≥n (l√≠nea ~3431).

 3.5. Renderizar Modal OCR

 {/* Agregar despu√©s de otros modales, cerca de l√≠nea ~3800 */}
 {showOcrStudiesModal && (
   <OCRStudiesModal
     isOpen={showOcrStudiesModal}
     onClose={() => {
       setShowOcrStudiesModal(false);
       setOcrFiles([]);
     }}
     onConfirm={handleOcrTextConfirmed}
     files={ocrFiles}
   />
 )}

 3.6. Crear Ref para Input

 // Agregar junto a otros refs, l√≠nea ~145
 const ocrStudiesInputRef = useRef<HTMLInputElement>(null);

 ---
 4. Modificaciones en DiagnosticAlgorithmContent.tsx

 Archivo: src/DiagnosticAlgorithmContent.tsx

 4.1. Cambiar Comportamiento del Bot√≥n OCR Existente

 Ubicaci√≥n actual: L√≠nea ~488-501 (bot√≥n "OCR notas")

 Cambios:

 {/* Reemplazar bot√≥n OCR actual */}
 {isAdminMode && (
   <>
     <input
       type="file"
       ref={ocrFileInputRef}
       onChange={(e) => handleOcrFileSelected(e.target.files)}
       accept="image/jpeg,image/jpg,image/png,image/bmp,image/t
 iff,application/pdf"
       multiple
       className="hidden"
     />
     <button
       onClick={() => ocrFileInputRef.current?.click()}
       disabled={ocrProcessing}
       className="flex items-center gap-1 px-2 py-1 text-xs
 font-medium text-white bg-purple-600 rounded
 hover:bg-purple-700 transition-colors disabled:opacity-50"
       title="Cargar y extraer texto de estudios m√©dicos"
     >
       <FileText size={14} />
       {ocrProcessing ? 'Procesando...' : 'Cargar Estudio
 (OCR)'}
     </button>
   </>
 )}

 4.2. Nuevos Estados y Refs

 // Agregar cerca de l√≠nea ~80
 const [ocrProcessing, setOcrProcessing] = useState(false);
 const [ocrFilesSelected, setOcrFilesSelected] =
 useState<File[]>([]);
 const ocrFileInputRef = useRef<HTMLInputElement>(null);

 4.3. Nueva Funci√≥n Handler

 const handleOcrFileSelected = useCallback((files: FileList |
 null) => {
   if (!files || files.length === 0) return;

   const validFiles = Array.from(files).filter(file =>
     file.type.startsWith('image/') || file.type ===
 'application/pdf'
   );

   if (validFiles.length === 0) {
     console.error('No se seleccionaron archivos v√°lidos para
 OCR');
     return;
   }

   setOcrFilesSelected(validFiles);
   setShowOcrModal(true); // Reutiliza el modal existente
 OCRProcessorModal
 }, []);

 4.4. Modificar handleInsertOcrText

 // Modificar funci√≥n existente, l√≠nea ~135
 const handleInsertOcrText = useCallback((extractedText:
 string) => {
   const cleanedText = extractedText.trim();
   const trimmedCurrentNotes = notes.trim().length === 0 ? '' :
  notes.trimEnd();

   // Concatenaci√≥n simple con doble salto de l√≠nea
   const mergedNotes = trimmedCurrentNotes.length > 0
     ? `${trimmedCurrentNotes}\n\n${cleanedText}`
     : cleanedText;

   setNotes(mergedNotes);
   setShowOcrModal(false);
   setOcrFilesSelected([]);
   setOcrProcessing(false);
 }, [notes, setNotes]);

 Nota: El Evolucionador puede reutilizar el componente
 OCRProcessorModal.tsx existente ya que su comportamiento
 (procesar ‚Üí mostrar texto ‚Üí insertar) coincide con el flujo
 deseado. Solo se cambia el trigger (input file en vez de bot√≥n
  directo).

 ---
 5. Base de Datos

 No se requieren cambios en la base de datos. Los campos
 existentes son suficientes:
 - ward_round_patients.estudios (TEXT) - ya existe
 - outpatient_ward_rounds.estudios (TEXT) - ya existe
 - Evolucionador usa el campo notes local (no persiste a
 estudios separado)

 ---
 6. Validaciones y Manejo de Errores

 Validaci√≥n de Archivos

 // En ocrAutoService.ts
 function isValidStudyImage(file: File): boolean {
   const validTypes = [
     'image/jpeg',
     'image/jpg',
     'image/png',
     'image/bmp',
     'image/tiff'
   ];

   return validTypes.includes(file.type.toLowerCase());
 }

 Errores Comunes a Manejar

 1. Archivo no soportado:
   - Mensaje: "Solo se aceptan im√°genes JPEG, PNG, BMP o TIFF"
   - Acci√≥n: Ignorar archivo, continuar con los v√°lidos
 2. OCR falla (Tesseract error):
   - Mensaje: "Error al procesar imagen: [nombre]. Intente con
 una imagen de mejor calidad"
   - Acci√≥n: Agregar a lista de errores, permitir continuar
 3. No se detect√≥ texto:
   - Mensaje: "No se detect√≥ texto legible en la imagen
 [nombre]"
   - Acci√≥n: Advertir al usuario, permitir ingreso manual
 4. Timeout (>30 segundos):
   - Mensaje: "El procesamiento est√° tardando demasiado. Por
 favor intente con im√°genes m√°s peque√±as"
   - Acci√≥n: Cancelar OCR, mostrar error

 Toast Notifications

 Usar sistema de toast existente para feedback:

 // √âxito
 toast.success('Texto extra√≠do correctamente de 3 archivos');

 // Advertencia (texto parcial)
 toast.warning('Se procesaron 2 de 3 archivos. 1 archivo no
 conten√≠a texto legible');

 // Error
 toast.error('Error al procesar OCR. Verifique que las im√°genes
  sean legibles');

 ---
 7. UX y Flujo de Usuario

 Ward Rounds - Flujo Completo

 1. Usuario abre formulario de agregar/editar paciente
 2. Va a secci√≥n "Estudios Complementarios"
 3. Click en bot√≥n "Extraer texto (OCR)" (nuevo bot√≥n morado
 con √≠cono FileText)
 4. Selecciona 1-3 archivos JPEG de laboratorios/ECG
 5. Se abre OCRStudiesModal:
   - Estado inicial: "Procesando archivo 1 de 3..." con spinner
   - Barra de progreso visual
 6. Tesseract procesa cada imagen secuencialmente (5-10 seg
 c/u)
 7. Modal muestra texto extra√≠do en textarea editable:
 Glucemia: 120 mg/dl
 Hemoglobina: 14.5 g/dl

 Ritmo sinusal
 FC: 80 lpm

 TC cerebro: sin lesiones agudas
 8. Usuario puede:
   - Editar el texto extra√≠do
   - Click "Agregar al campo" ‚Üí texto se inserta en el campo
 "Estudios Complementarios"
   - Click "Cancelar" ‚Üí descarta todo
 9. Modal se cierra, texto aparece en el textarea de estudios
 10. Usuario completa otros campos y guarda el paciente
 normalmente
 11. Imagen JPEG NO se guarda en Supabase Storage (solo el
 texto)

 Evolucionador - Flujo Completo

 1. Usuario abre Evolucionador (modo admin)
 2. Click en "Cargar Estudio (OCR)" (reemplaza bot√≥n "OCR
 notas" actual)
 3. Selecciona archivo(s) PDF o JPEG
 4. Se abre OCRProcessorModal existente
 5. Procesa con OCR (mismo comportamiento que antes)
 6. Muestra texto en modal para revisi√≥n
 7. Usuario hace click en "Insertar"
 8. Texto se agrega al campo de notas con doble salto de l√≠nea
 9. Imagen NO se guarda (solo texto extra√≠do)

 ---
 8. Consideraciones de Performance

 Procesamiento Secuencial vs Paralelo

 Decisi√≥n: Procesamiento secuencial (uno por uno)

 Raz√≥n:
 - Tesseract.js es CPU-intensivo (puede colgar navegador si
 procesa 3 en paralelo)
 - Progreso visual m√°s claro para el usuario
 - Menos memoria consumida (mobile-friendly)

 Implementaci√≥n:
 for (let i = 0; i < files.length; i++) {
   const result = await processImageForStudies(files[i],
     (progress) => onProgress(i + 1, files.length, progress)
   );
   results.push(result);
 }

 Optimizaci√≥n Mobile

 - Limitar a 3 archivos m√°ximo por vez
 - Mostrar advertencia si archivo > 5 MB
 - Comprimir imagen antes de OCR (opcional, para futuro)

 Tiempo Estimado

 - 1 imagen JPEG (buena calidad): ~5-8 segundos
 - 1 imagen JPEG (mala calidad): ~10-15 segundos
 - 3 im√°genes: ~15-30 segundos total

 UX: Mostrar tiempo estimado: "Procesando... ~15 segundos
 restantes"

 ---
 9. Testing y Validaci√≥n

 Casos de Prueba

 1. Caso feliz: 1 JPEG legible ‚Üí texto extra√≠do correctamente
 2. M√∫ltiples archivos: 3 JPEGs ‚Üí concatenaci√≥n correcta
 3. Imagen borrosa: JPEG de mala calidad ‚Üí advertencia de texto
  incompleto
 4. Archivo inv√°lido: PNG de 20 MB ‚Üí error de formato/tama√±o
 5. Sin texto: JPEG de foto (no documento) ‚Üí advertencia "no se
  detect√≥ texto"
 6. Cancelaci√≥n: Usuario cancela durante procesamiento ‚Üí limpia
  estado
 7. Edici√≥n de texto: Usuario edita texto extra√≠do antes de
 confirmar ‚Üí guarda versi√≥n editada
 8. Concatenaci√≥n con existente: Campo estudios tiene texto ‚Üí
 nuevo texto se agrega al final

 Validaci√≥n Manual

 - Probar en Chrome Desktop
 - Probar en Safari Mobile (iPhone)
 - Probar en Chrome Mobile (Android)
 - Verificar que im√°genes NO se guardan en Supabase Storage
 - Verificar que solo texto se guarda en campo estudios
 - Probar con PDFs (en Evolucionador)
 - Verificar dark mode en todos los modales
 - Verificar responsiveness en tablet

 ---
 10. Orden de Implementaci√≥n (Paso a Paso)

 Fase 1: Servicio Base (1-2 horas)

 1. ‚úÖ Crear src/services/ocrAutoService.ts
 2. ‚úÖ Implementar processImageForStudies()
 3. ‚úÖ Implementar processMultipleImagesForStudies()
 4. ‚úÖ Implementar validaci√≥n isValidStudyImage()
 5. ‚úÖ Testing unitario del servicio

 Fase 2: Componente Modal (2-3 horas)

 1. ‚úÖ Crear src/components/OCRStudiesModal.tsx
 2. ‚úÖ Implementar UI de progreso
 3. ‚úÖ Implementar UI de preview con textarea editable
 4. ‚úÖ Implementar manejo de errores
 5. ‚úÖ Testing del componente aislado
 6. ‚úÖ Verificar dark mode

 Fase 3: Integraci√≥n Ward Rounds (2-3 horas)

 1. ‚úÖ Agregar estados y refs en WardRounds.tsx
 2. ‚úÖ Implementar handleOcrStudiesUpload()
 3. ‚úÖ Implementar handleOcrTextConfirmed()
 4. ‚úÖ Modificar UI de formulario agregar (bot√≥n OCR)
 5. ‚úÖ Modificar UI de formulario editar (bot√≥n OCR)
 6. ‚úÖ Renderizar OCRStudiesModal
 7. ‚úÖ Testing en desarrollo

 Fase 4: Integraci√≥n Evolucionador (1-2 horas)

 1. ‚úÖ Modificar bot√≥n OCR en DiagnosticAlgorithmContent.tsx
 2. ‚úÖ Agregar input file y handler
 3. ‚úÖ Reutilizar OCRProcessorModal existente
 4. ‚úÖ Testing en desarrollo

 Fase 5: Testing y Ajustes (1-2 horas)

 1. ‚úÖ Testing completo en desktop
 2. ‚úÖ Testing en mobile (Chrome + Safari)
 3. ‚úÖ Ajustes de UX seg√∫n feedback
 4. ‚úÖ Verificar que NO se guardan im√°genes
 5. ‚úÖ Validar rendimiento con m√∫ltiples archivos

 Tiempo total estimado: 7-12 horas de desarrollo

 ---
 11. Archivos a Crear/Modificar

 Nuevos Archivos

 1. src/services/ocrAutoService.ts - Servicio de OCR autom√°tico
 2. src/components/OCRStudiesModal.tsx - Modal de preview y
 confirmaci√≥n

 Archivos a Modificar

 1. src/WardRounds.tsx:
   - Agregar estados: showOcrStudiesModal, ocrFiles,
 ocrProcessing
   - Agregar ref: ocrStudiesInputRef
   - Agregar funciones: handleOcrStudiesUpload,
 handleOcrTextConfirmed
   - Modificar UI: bot√≥n OCR en secci√≥n Estudios (formularios
 agregar + editar)
   - Renderizar modal: <OCRStudiesModal />
 2. src/DiagnosticAlgorithmContent.tsx:
   - Modificar bot√≥n OCR existente (l√≠nea ~488)
   - Agregar input file oculto
   - Agregar estados: ocrProcessing, ocrFilesSelected
   - Agregar ref: ocrFileInputRef
   - Agregar handler: handleOcrFileSelected

 Archivos a NO Modificar (reutilizar)

 - src/services/ocrService.ts - Se reutiliza tal cual
 - src/components/admin/OCRProcessorModal.tsx - Se reutiliza en
  Evolucionador

 ---
 12. Dependencias

 Bibliotecas Existentes (ya instaladas)

 - ‚úÖ tesseract.js@^6.0.1 - OCR de im√°genes
 - ‚úÖ pdfjs-dist@^5.4.149 - OCR de PDFs (solo Evolucionador)
 - ‚úÖ lucide-react - Iconos (FileText, FlaskConical)

 No se requieren nuevas dependencias

 ---
 13. Consideraciones de Seguridad

 1. Validaci√≥n de archivos: Solo permitir tipos espec√≠ficos
 (JPEG, PNG, BMP, TIFF)
 2. Tama√±o m√°ximo: Advertir si archivo > 5 MB (opcional,
 implementar si hay problemas)
 3. No persistir im√°genes: Importante para privacidad y
 compliance HIPAA
 4. Sanitizaci√≥n de texto: Limpiar el texto extra√≠do antes de
 guardarlo en BD
 5. RLS policies: Existentes en ward_round_patients ya cubren
 acceso a campo estudios

 ---
 14. Notas Importantes

 Diferencias entre Ward Rounds y Evolucionador

 | Aspecto             | Ward Rounds                      |
 Evolucionador                 |
 |---------------------|----------------------------------|----
 ---------------------------|
 | Componente modal    | OCRStudiesModal (nuevo)          |
 OCRProcessorModal (existente) |
 | Formatos soportados | Solo im√°genes (JPEG, PNG, etc.)  |
 Im√°genes + PDF                |
 | Campo destino       | estudios (separado)              |
 notes (general)               |
 | Ubicaci√≥n bot√≥n     | Secci√≥n Estudios Complementarios |
 Toolbar superior              |
 | Usuarios            | Todos (seg√∫n RLS)                |
 Solo admin mode               |

 Limitaciones Conocidas

 1. Calidad de OCR: Depende de calidad de imagen (Tesseract no
 es perfecto)
 2. Idioma: Configurado para espa√±ol + ingl√©s (puede fallar con
  otros idiomas)
 3. Texto manuscrito: OCR funciona mejor con texto
 impreso/digital
 4. Performance mobile: Puede ser lento en dispositivos
 antiguos
 5. No se guardan im√°genes: Decisi√≥n de dise√±o, texto es
 irrecuperable si se pierde

 Mejoras Futuras (Fuera de Scope)

 - Permitir guardar imagen como fallback opcional
 - Compresi√≥n autom√°tica de im√°genes grandes
 - OCR en tiempo real (stream de c√°mara)
 - Campos estructurados para tipos de estudios
 - Integraci√≥n con sistemas de laboratorio (HL7/FHIR)
 - Machine learning para mejorar precisi√≥n

 ---
 15. Checklist de Implementaci√≥n

 Pre-implementaci√≥n

 - Leer este plan completo
 - Entender flujo de usuario deseado
 - Revisar c√≥digo de ocrService.ts y OCRProcessorModal.tsx
 existentes
 - Configurar entorno de desarrollo (Tesseract ya instalado)

 Desarrollo

 - Crear ocrAutoService.ts con funciones base
 - Crear OCRStudiesModal.tsx con UI completa
 - Integrar en Ward Rounds (agregar + editar)
 - Integrar en Evolucionador (reemplazar bot√≥n)
 - Probar localmente cada integraci√≥n

 Testing

 - Probar con 1 imagen JPEG legible
 - Probar con m√∫ltiples im√°genes (2-3)
 - Probar con imagen borrosa/ilegible
 - Probar cancelaci√≥n de modal
 - Probar edici√≥n de texto antes de confirmar
 - Verificar que NO se guardan im√°genes en Storage
 - Verificar concatenaci√≥n con texto existente
 - Probar en mobile (Chrome + Safari)
 - Verificar dark mode

 Pre-producci√≥n

 - Verificar todos los mensajes de error son user-friendly
 - Verificar performance con archivos grandes (3-5 MB)
 - Code review de seguridad (validaci√≥n de archivos)
 - Verificar accesibilidad (teclado, screen readers)

 Deploy

 - Commit con mensaje descriptivo
 - Push a repositorio
 - Verificar build en Vercel (no debe romper)
 - Testing en producci√≥n con datos reales
 - Monitorear errores en Sentry/logs

 ---
 16. Contacto y Soporte

 Desarrollador: Dr. Juli√°n Alonso
 Repositorio: https://github.com/jutopa31/HUBjr-v2
 Documentaci√≥n: Ver CLAUDE.md para patrones de c√≥digo

 Recursos:
 - https://tesseract.projectnaptha.com/
 - ../CLAUDE.md - Gu√≠a de desarrollo del proyecto
 - https://supabase.com/docs/guides/storage

 ---
 Fin del Plan de Implementaci√≥n

 √öltima actualizaci√≥n: 2025-12-09